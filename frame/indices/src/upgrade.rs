
// Template for pallet upgrade for Indices

pub use pallet::*;

#[frame_support::pallet]
pub mod pallet {
	use frame_support::pallet_prelude::*;
	use frame_system::pallet_prelude::*;
	use super::*;

	#[pallet::config]
	pub trait Config: frame_system::Config
		// TODO_MAYBE_ADDITIONAL_BOUNDS_AND_WHERE_CLAUSE
	{
		// TODO_ASSOCIATED_TYPE_AND_CONSTANTS
	}

	

	#[pallet::pallet]
	#[pallet::generate_store(pub(super) trait Store)]
	pub struct Pallet<T>(PhantomData<T>);

	#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T>
		// TODO_MAYBE_WHERE_CLAUSE
	{
		// TODO_ON_FINALIZE
		// TODO_ON_INITIALIZE
		// TODO_ON_RUNTIME_UPGRADE
		// TODO_INTEGRITY_TEST
		// TODO_OFFCHAIN_WORKER
	}

	#[pallet::call]
	impl<T: Config> Pallet<T>
		// TODO_MAYBE_WHERE_CLAUSE
	{
		// TODO_UPGRADE_DISPATCHABLES
	}

	#[pallet::inherent]
	// TODO_INHERENT

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	// TODO_EVENT

	// TODO_REMOVE_IF_NO_EVENT
	/// Old name generated by `decl_event`.
	#[deprecated(note="use `Event` instead")]
	pub type RawEvent /* TODO_PUT_EVENT_GENERICS */ = Event /* TODO_PUT_EVENT_GENERICS */;

	#[pallet::error]
	// TODO_ERROR

	#[pallet::origin]
	// TODO_ORIGIN

	#[pallet::validate_unsigned]
	// TODO_VALIDATE_UNSIGNED

	

	/// The lookup from index to account.
	#[pallet::storage]
	pub type Accounts<T: Config> = StorageMap<_, Blake2_128Concat, T::AccountIndex, (T::AccountId, BalanceOf<T>, bool)>;

	
	#[pallet::genesis_config]
	pub struct GenesisConfig<T: Config>
		// TODO_MAYBE_WHERE_CLAUSE
	{
		pub indices: Vec<(T::AccountIndex, T::AccountId)>,
	}

	#[cfg(feature = "std")]
	impl<T: Config> Default for GenesisConfig<T>
		// TODO_MAYBE_WHERE_CLAUSE
	{
		fn default() -> Self {
			Self {
				indices: Default::default(),
			}
		}
	}

	
	#[pallet::genesis_build]
	impl<T: Config> GenesisBuild<T> for GenesisConfig<T>
		// TODO_MAYBE_WHERE_CLAUSE
	{
		fn build(&self) {
					{
    let builder : fn(& Self) -> _ = | config : & GenesisConfig<T> | config
    . indices . iter() . cloned() .
    map(|(a, b) |(a,(b, Zero::zero(), false))) . collect::<Vec<_>>
   (); let data = & builder(self); let data : & frame_support::sp_std::
    vec::Vec<(T::AccountIndex,(T::AccountId, BalanceOf<T>, bool))
   > = data; data . iter() .
    for_each(|(k, v) |
             {
                <Accounts<T,> as frame_support::storage::StorageMap<
                 T::AccountIndex,(T::AccountId, BalanceOf<T>, bool)>
                >::insert::<& T::AccountIndex, &
                (T::AccountId, BalanceOf<T>, bool)>(k, v);
             });
}
		}
	}
}
